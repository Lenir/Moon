---
layout:       post
title:        "[Study] 임시 모듬"
date:         2017-10-19
author :      "Lenir"
catalog:      true
header-mask:  0.7
multilingual: false
mathjax:      true
tags:
- Study
- OS
- Network
- DB
- Algorithm

comments: true
---
### 운영체제

### 데이터베이스
#### SQL
##### INSERT
{% highlight sql %}
INSERT INTO table(name, age, sex)
VALUES ('Lenir', 27, 'male');
{% endhighlight %}
table에 (name, age, sex)의 값이 ('Lenir', 27, 'male')인 튜플을 삽입하는 INSERT 명령입니다.
##### UPDATE
{% highlight sql %}
UPDATE table
SET age = 27, sex = 'male'
WHERE name = 'Lenir';
{% endhighlight %}
name값이 'Lenir'인 튜플의 age, sex 값을 27, 'male'로 바꾸는 UPDATE 명령입니다.
##### DELETE
{% highlight sql %}
DELETE
FROM table
WHERE name = 'Lenir';
{% endhighlight %}
name값이 'Lenir'인 튜플을 지우는 DELETE 명령입니다.
##### JOIN
###### Cross Join
단순히 테이블 합치기. 튜플의 갯수는 \\(table1.size() * table2.size()\\)가 됩니다.
{% highlight sql %}
SELECT *
FROM table1, table2;
{% endhighlight %}
table1과 table2의 모든 튜플을 JOIN하여 모두 보여주는 구문입니다.
###### Inner Join
Inner Join은 조건에 맞는 튜플들만 Join하는것으로,
사원들 정보(이름, 사원번호, 성별, 소속팀)가 담긴 테이블 emp와 사원들의 월급 지급내역(사원번호, 지급일자, 월급)이 있는 테이블 sal이 있다고 칩시다. 그러면 테이블에 있는 튜플들은 다음과 같을 겁니다. <br>

{% highlight sql %}
emp = (emp.name, emp.num, emp.sex, emp.team);
sal = (sal.empNum, sal.date ,sal.salary);
{% endhighlight %}

여기서 사원별로 월급 지급 내역을 뽑아서 이름이 'Lenir'인 사원의 결과를 검색하려면 다음과 같이 하면 될 것입니다.

{% highlight sql %}
SELECT emp.num, emp.name, sal.date, sal.sal
FROM emp
JOIN sal
ON emp.num = sal.num
WHERE emp.name = 'Lenir';
{% endhighlight %}

즉, 조건에 맞는(위의 예시에서는 emp의 사원번호와 sal의 사원번호가 일치하는) 튜플만 Join해서 보여주는 것이 Inner join입니다.<br>
하나 더 예시를 들어 볼까요. 이번엔 사원 번호, 사원 이름, 사원별 월급의 합을 사원 번호로 정렬해봅시다.

{% highlight sql %}
SELECT emp.num, emp.name, sal.date, SUM(sal.sal)
FROM emp
JOIN sal
ON emp.num = sal.num
GROUP BY emp.num
ORDER BY emp.num
{% endhighlight %}

###### Outer Join
기준 테이블에선 조건에 맞지 않는 튜플도 Join. 기준에 따라 Left, Right, Full Outer Joind으로 나뉩니다. Left/Right는 해당 테이블, Full Outer Join은 두 테이블 모두 모든 튜플이 나오는 겁니다. 즉, Left Join과 Right Join의 결과를 합친게 되는거죠.<br>
존재하지 않는 데이터는 NULL이 됩니다.
{% highlight sql %}
SELECT *
FROM emp
LEFT JOIN sal
ON emp.num = sal.num
ORDER BY emp.name
{% endhighlight %}
LEFT JOIN을 했으니 왼쪽에 있는 테이블, 즉 emp 테이블은 조건에 맞지 않아도 모두 나올겁니다. 즉, 아직 월급 지급내역이 없는 신입들도 나온다는 거지요. 물론, join해서 생겨야 할 sal 테이블의 속성 값들은 모두 null이 되어 보이겠지만요.
##### Union
{% highlight sql %}
UPDATE table SET field1=value1, field2=value2, WHERE condition;
{% endhighlight %}


### 네트워크
#### OSI 7 Layers
![](/img/network/OSI.jpg)
##### 1L - Physical Layer
가장 하부인 물리 계층입니다. 통신을 위한 물리적인 성질(전압, 전선, 핀 레이아웃 등)울 정의합니다.

##### 2L - Data Link Layer
Point-to-Point간의 신뢰성 있는 연결을 보장하기 위한 레이어입니다. Flow Control, Congestion Control, Error Control 등이 주 역할입니다. MAC이 대표적(Media Access Control)이고, MAC Address로 구분됩니다.

##### 3L - Network Layer
네트워크 노드 간의 경로를 찾아주는 레이어입니다. 즉, Inter-Networking을 위한 Router가 존재합니다. IP(Internet Protocol)이 대표적이고, IP Address로 구분됩니다.

##### 4L - Transport Layer
전송 계층. End-to-End간의 신뢰성 있는 연결을 보장하기 위한 레이어. 상위 레이어인 세션, 프리젠테이션, 어플리케이션 레이어들이 하부 레이어들에서 나온 오류를 생각할 필요가 없게 만듬. TCP(Transmission Control Protocol)이 대표적.

##### 5L - Session Layer
TCP/IP 세션을 만들고 없애는 레이어.

##### 6L - Presentation Layer
암/복호화 번역 레이어.

##### 7L - Application Layer
직접 어플리케이션과 연계하는 레이어.

#### TCP, Transmission Control Protocol
연결 지향 프로토콜입니다. 패킷 스위칭 방식을 사용하며 발생하는 문제들을 컨트롤합니다. 3-Way Handshacking을 통해 연결을 설정한 후(SYN - ACK,SYN - ACK) 통신을 하는 것이 특징입니다. 대표적인 역할로는 Flow Control, Congestion Control이 있습니다.
##### Flow Control
![](/img/network/tcp-sliding-window.jpg)
수신 측에서 버퍼에 저장할 시간이 필요하기 때문에 송신 측에서는 현재 데이터의 프레임 순서번호, 패리티 코드 등을 같이 보내고, 수신 측에서는 ACK에 받을 프레임 번호를 같이 보내준다. 여기서 사용되는 것이 슬라이딩 윈도우인데, 버퍼 사이즈만큼 윈도우가 옮겨가는 것처럼 보면 될 것이다.


### 알고리즘









<br><br>
